DinarScript {

  Program     = Statement+

  Statement   = SimpleStmt
              | FunDecl
              | WhileStmt
              | IfStmt
              | MatchStmt
              | RecordDecl

  SimpleStmt  = (VarDecl | Assignment | ReturnStmt | BreakStmt | ShowStmt | Exp) ";"

  VarDecl     = (let | final) id TypeAnn? "=" Exp
  TypeAnn     = ":" Type

  FunDecl     = fun id Params ReturnType? ":" Block endkw
  Params      = "(" ListOf<Param, ","> ")"
  Param       = id ":" Type
  ReturnType  = "->" Type

  WhileStmt   = while Exp ":" Block endkw
  IfStmt      = if Exp ":" Block ElsePart? endkw
  ElsePart    = else ":" Block

  MatchStmt   = match Exp ":" Case+ endkw
  Case        = case Pattern ":" Block

  Pattern     = "_"
              | true
              | false
              | MoneyLit
              | MoneyCtor
              | number
              | string
              | id

  RecordDecl  = record id "{" FieldDecl* "}"
  FieldDecl   = Access id ":" Type ";"
  Access      = public | private

  Assignment  = id "=" Exp
  ReturnStmt  = ret Exp?
  BreakStmt   = break
  ShowStmt    = show "(" Exp ")"

  Block       = Statement*

  Type        = IntType | BoolType | StringType | DecType | KDType | VoidType
  IntType     = "Int" ~alnum
  BoolType    = "Bool" ~alnum
  StringType  = "String" ~alnum
  DecType     = "Dec" ~alnum
  KDType      = "KD" ~alnum
  VoidType    = "Void" ~alnum

  Exp         = ExpOr

  ExpOr       = ExpAnd OrTail*
  OrTail      = "or" ExpAnd

  ExpAnd      = ExpEq AndTail*
  AndTail     = "and" ExpEq

  ExpEq       = ExpRel EqTail*
  EqTail      = ("==" | "!=") ExpRel

  ExpRel      = ExpAdd RelTail*
  RelTail     = ("<=" | "<" | ">=" | ">") ExpAdd

  ExpAdd      = ExpMul AddTail*
  AddTail     = ("+" | "-") ExpMul

  ExpMul      = ExpUnary MulTail*
  MulTail     = ("*" | "/") ExpUnary

  ExpUnary    = UnaryOp* ExpPostfix
  UnaryOp     = "-" | "not"

  ExpPostfix  = Primary Postfix*
  Postfix     = Call | Field
  Call        = "(" ListOf<Exp, ","> ")"
  Field       = "." id

  Primary     = ParenExp
              | true
              | false
              | MoneyLit
              | MoneyCtor
              | number
              | string
              | id

  ParenExp    = "(" Exp ")"

  MoneyCtor   = KDCall | FilsCall
  KDCall      = kd "(" number ")"
  FilsCall    = fils "(" digit+ ")"

  MoneyLit     = BuiltInDenom | KDWhole | FilsWhole | KDMixed
  BuiltInDenom = QuarterKD | HalfKD | OneKD | FiveKD | TenKD | TwentyKD

  QuarterKD   = "1/4kd" ~alnum
  HalfKD      = "1/2kd" ~alnum
  OneKD       = "1kd" ~alnum
  FiveKD      = "5kd" ~alnum
  TenKD       = "10kd" ~alnum
  TwentyKD    = "20kd" ~alnum

  KDWhole     = digit+ kd
  FilsWhole   = digit+ fils
  KDMixed     = digit+ kd digit+ fils

  number      = digit+ ("." digit+)?
  string      = "\"" (~"\"" any)* "\""

  let         = "let" ~alnum
  final       = "final" ~alnum
  fun         = "fun" ~alnum
  endkw       = "end" ~alnum
  while       = "while" ~alnum
  if          = "if" ~alnum
  else        = "else" ~alnum
  match       = "match" ~alnum
  case        = "case" ~alnum
  record      = "record" ~alnum
  public      = "public" ~alnum
  private     = "private" ~alnum
  break       = "break" ~alnum
  ret         = "return" ~alnum
  show        = "show" ~alnum

  kd          = "kd" ~alnum
  fils        = "fils" ~alnum

  true        = "true" ~alnum
  false       = "false" ~alnum

  reserved    = let | final | fun | endkw | while | if | else | match | case
              | record | public | private | break | ret | show
              | kd | fils
              | true | false
              | ("Int" ~alnum)
              | ("Bool" ~alnum)
              | ("String" ~alnum)
              | ("Dec" ~alnum)
              | ("KD" ~alnum)
              | ("Void" ~alnum)

  id          = ~reserved letter (alnum | "_")*

  comment     = "//" (~"\n" any)*
  space      += comment
}
